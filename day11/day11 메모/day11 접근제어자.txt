[ (접근)제어자 ]

일반적으로 public 이 디폴트 -> 단순 연산자로의 (외부로부터의) 접근을 막고싶다 ! -> private
private -> 해당 클래스 내부에서만 접근 가능 !
				"모든 멤버변수에게는 private을 설정"
				+ getter, setter을 함께 생성 
				↓
외부에서 직접적으로 멤버변수의 값에 접근할 수는 없으나,
getter, setter 를 인지하고 있으면 값을 바꿀수 있다!
"캡슐화" ocj 테스트에 냄 


추상 클래스 
1. 객체화(인스턴스화) 불가능
   생성자를 가질수있음에 유의!!!
   new 연산자와 함께 사용 xxxxx
2. 추상메서드를 소유할수있음
   => 오버라이딩을 "강제"				
   => 엄청 좋은거다 ! // 뭔가 기능을 강제하면 하라는 대로 하면 되서 좋다.
    	=> 메서드 바디{}를 가질수없음


class Player
   최대 3마리의 포켓몬을 소유할수있다.
   Player 생성시 최초 소지 포켓몬은 무조건 피카츄이다.
   final static int maxIndex=3;
   int preIndex; // 1
   Pokemon[] data; // new Pokemon[maxIndex]
   // data[0]=new 피카츄();
   void play()
      // data에 저장된 포켓몬을 랜덤으로 2마리 선택하여 게임을 진행
      // 단, 2마리의 포켓몬이 서로 같은 포켓몬이면 더이상 진행하지않음 [Object최상위클래스->equals() 오버라이딩]
               클래스 타입이 같으면 같은 포켓몬
      // 서로 다른 포켓몬이면 포켓몬.game()을 진행함
      // 이긴 포켓몬의 울음소리가 console에 출력됨
      // 포켓몬.hello()

class Pokemon [abstract]
   String name;
   int win; // 이긴횟수
   void hello() // 울음소리. 하위클래스에 따라 수행되는 기능이 다름에 유의 [오버라이딩 강제->추상메서드]
   boolean game(Pokemon pokemon)
      // win이 홀홀일때는 작은쪽이 이김
      // win이 짝짝일때는 큰쪽이 이김
      // win이 홀짝일때는 홀수가 이김
      // win이 동일하다면 주어(주체)가 이김
      // 이후 이긴쪽의 win이 1 증가



1. 포켓몬 추가
2. 가진 포켓몬 전체 출력
3. 게임시키기
4. 프로그램 종료









[ (접근)제어자 ]
public -> 단순 연산자로(외부로부터)의 접근을 막고싶다!
private -> 해당 클래스 내부에서만 접근가능!!!
   "모든 멤버변수에게는 private을 설정"
    + "getter,setter을 함께 생성"
   ↓
외부에서 직접적으로 멤버변수의 값에 접근할수는없으나,
getter,setter를 인지하고있으면 값을 바꿀수있다!
"캡슐화"



[ 추상 클래스 (abstract class) ]
1. 객체화(인스턴스화) 불가능
   생성자를 가질수있음에 유의!!!
   new 연산자와 함께 사용 xxxxx
2. 추상메서드를 소유할수있음
   => 오버라이딩을 "강제"
         => 엄청좋은거다!
   => 메서드 바디{}를 가질수없음














1. this.   this()
2. 객체 배열
3. super()
4. 오버라이딩(메서드 재정의)
5. private + getter,setter

[추상화]
   설계에 필요한 클래스(객체화 관심 x)
   abstract
[캡슐화]
   private + getter,setter
[상속]
   extends
   코드 재사용성 증가
[다형성]
   A,B,C객체가 동일한 기능을 수행했어도
   서로다른 효과가 나타나야할때
   => 다형성을 실현시켜야하는구나~!!

















			
