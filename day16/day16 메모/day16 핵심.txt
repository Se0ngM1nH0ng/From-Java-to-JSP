★ 결합도 낮추기 ★

결합도가 낮으면 ?
-> 유지보수에 용이

짜놓은 코드를 마지막으로 확인할 때
정말 결합도가 낮은지를 체크하기.

체크했더니, if

이 코드, 결합도가 높네 ?

=> 어떤 요구사항이 발생 했을 때,
코드의 "여러 부분(파트)를 수정 해야 하는 상황"
== 결합도가 높다.
(연쇄적으로 코드를 바꿔야 하는 상황)

DAO의 CRUD(비즈니스 메서드, 핵심 로직)는
어떠한 추가적인 요구사항에도 절대로 !!!
"메서드 시그니쳐"가 변하지 않도록 코드를 작성 한다.

why? 메서드 시그니쳐가 바뀌면 다른 파트에 영향을 미쳐.

그래서, 수정할게 생겼을 때 내부의 기능에 영향이 가는
메서드 시그니쳐를 수정하는게 아니라,
영향을 미치지 않게 코드를 수정 해야 한다.
즉, 외부에서 코드를 추가하거나 수정하는 느낌으로 가야 한다.

결론 : "메서드 시그니쳐"는 설계 단계에서 절대로 변경되면 안된다.

따라서 모델을 건들지 않고, 컨트롤러에서만 해결이 되게 !

메서드 시그니쳐의 인자를
String name, int price, .. 으로 각각에 인자로
설정해두는게 아니라, (이러면 변경이 가능하기에..)

"인자에 고정값"을 줘야 한다.
★★★ DAO의 CRUD 메서드의 인자를 VO 클래스명으로 통일 ★★★

그러면, 그것을 사용할 때는 VO 클래스의 객체를 생성 해서,
참조변수(vo).메서드 로 활용 한다.

DAO의 CRUD에게 전달 해야 하는 값만 설정 한다.
전달하지 않아도 되는 null 또는 0으로 표기 한다.

결국, VO의 생성자 "인자 갯수에 맞게 객체를 생성" 해주지만,

해당 기능에서 필요하지 않는 값은 null 또는 0으로 표기.

-----------------------------------------------

오버로딩이 불가능한 기능일 경우,
기능이 매우 유사한 것이기 때문에 내부 로직에서 분리해서 관리 한다.
-> 유사한 기능끼리는 묶어서 관리하는 것이 용이하기 때문이다.
==	응집도를 높힌다 == 유지보수에 유리.

---------------------------------------------------


개념 :

forEach (향상된 for 문) 은 오른쪽에 존재하는 컬렉션을 N차 시도때
N-1번째 인덱스(index)를 복사하여 사용 한다.

for문은 기존 배열[]의 방식을 그대로 사용 한다.
datas[i] == datas.get(i)

-----------------------------------------------

★ 장바구니 개념 ★

장바구니는 프로그램당 1개 ? -> 공용 장바구니 ?? X
장바구니는 사용자당 1개 !

-> 원래 장바구니는 같은 제품을 여러번 구매했을 때
커스터마이징 할일이 있으면, 개별적으로 관리하게 된다.


-----------------------------------------------

장바구니는 구매할때 구매에 성공해야지만, 장바구니에 들어와 질 수 있다.
(타이밍을 잘 생각해보기.. 어디에 들어가야할지..)

1. 프로그램이 시작되서 사용자가 새로 입장하면

2. 그때 장바구니가 생성된다.
장바구니 장바구니 = 초기화;

예를들어, 음료를 여러개 구매한다..
배열을 사용할까? 배열리스트를 사용할까? set을 사용할까?
정답은 배열리스트 이다.
(배열은 몇개 구매할지 모르니까 배열의 크기를 정할 수 없다)
헷갈리면 그냥 다 배열리스트 사용 하는 방향으로 생각하자.

3. ArrayList<DrinkVO> cart = new ArrayList<DrinkVO>();

4. 이 장바구니는 사용자가 프로그램을 종료하면 장바구니 메모리를 해제해준다.

5. 사실 새로 프로그램이 생성될때마다 새롭게 new 해서 초기화 되지만,
cart.clear();을 통해서 로직상에 구현..

6. ..?










