JAVA 에서 MVC 를 적용 한 것 처럼,
JSP 에서 프레임워크 구조를 적용 할 수 있다.
	-> C

1.
Controller.jsp 는 어차피 JAVA 밖에 없는데, 굳이 .jsp 에서 작업 해야 하나?
	


2.
.jsp 에서 하지 말고, .java 에서 Controller 페이지를 작업 하자.


3.
.jsp가 컴파일이 되면, 서블릿 (Servlet).java 파일로 된다 !
(ctrl + f11 해서 돌리기 == 컴파일)

=> ★ 즉, .jsp 파일은 컴파일이 되면 JAVA 파일이 된다는 말 ~


4.
대신, 일반적인 .java 파일로 작업을 하면 안된다.


5.
위에 정리했듯이, 서블릿 으로 작업을 해야 한다. 
서블릿은 NOT POJO ~


6.
1단계 : controller.jsp >>> Controller.java (Servlet) 으로 이동 ~


7.
2단계 : 현재의 Controller.java 는 모~~~든 코드를 하나의 .java 파일에서 관리 하는 중 이다.
	그래서, 1개의 action 에 문제가 발생하면,
	전체가 동작 하지 않게 된다.
	>>> 그래서 모듈화가 필요 하다. (유지 보수가 용이해 진다.)

	각각의 모듈화가 필요한 코드에 대해서, .java 파일 (POJO 클래스) 을 만들어 준다.

	어쩌구Action 클래스 로 파일명을 만들고,
	
	execute(request,response) 메서드를 만들어서 사용 한다.


8.

아니 근데, 필요한 VO DAO를 각각 다 만들어 줘야 하는데, 너무 VO DAO 노가다 아닌가 

사실 근데 원래 VO DAO 다 만들고 객체화 해서 사용 하긴 했었음.

그니까, 원래도 controller.jsp 을 방문하면 모든 객체를 생성했었다.

하지만 만약에 main 액션만 하면 되는 상황인데, 모든 VO DAO 객체를 생성 하면 이상 하지 않음?

그래서 앞으로 main 액션에 대한 VO DAO 객체만 생성 하려고 한다.

Controller.java 내부에 doAcion() 함수 내부를 보면,

모듈화를 해서 불러오고,

모듈화를 하기 위해서 만든 POJO 클래스는 각각의 경우에 대한 것들만 사용 하기 때문에,

객체를 모두 생성 하지 않고, 필요한 객체만 생성 하면 되니까, 모든 객체를 생성 하지 않게 되는 것이다.

근데, 매우~~ 귀찮다,, ? 암튼 POJO 클래스 많이 만들어야 하니까..

그래서, 이것을 해결 하기 위해서 아래의 방법을 사용 한다.


9.
3단계 : excute() 함수는 모든 곳에서 메서드 시그니쳐가 동일한 상황 이다.

그래서, 어쩌구Action 류의 클래스들을 정의할 클래스가 필요하다는 것을 생각 할 수 있음.

글구, 정의 하지 않으면 클래스 생성 과정에서 실수가 발생 할 수 있는 가능성도 있기에,

공통의 것들을 부모 클래스로 만들 수 있다. 나머지는 상속을 받는 느낌으로.

어쩌구Action 류들을 상속해줄 부모 클래스 이름은 Action 정도로 지어주면 될듯 ?

이 Action 이라는 부모 클래스에 abstract 키워드를 붙혀서 추상 클래스로 변경 한다.

왜 ? 어차피 다 사용 해야 하니까, 메서드 오버라이딩 강제 시켜도 되니까..

그러면, 객체 생성이 불가능하고, 메서드 오버라이딩을 강제 시킨다.
(부모의 추상 메서드를 상속받은 자식 클래스에서 오버라이딩 해서 기능을 구현)

근데 이렇게 메서드 오버라이딩만 강제 할 수는 없을까 ?

해서 나온 문법이 [인터페이스] 이다.

그래서 인터페이스를 사용 할 것이다.

인터페이스 이름을 Action 으로 해서 실습 했다.

[인터페이스]

>> 메서드 시그니쳐를 지켜준다.
>> public 키워드가 디폴트 이다. 그래서, 생략이 가능 하다.
>> 인터페이스를 구현한 클래스는 인터페이스의 메서드를 강제로 구현 해야만 한다.
>> 오버라이딩 자동으로 하면 @ ~~ 하면서 생성 된다.


10.
Controller.java 가 해야 하는 작업 (흐름)

	1) Client (== 브라우저 == 사용자) 가 보낸 요청을 추출 해야 한다.
		즉, 어떤 요청 (액션) 을 하고 싶었는지를 파악 하기.
	
	2) 추출한 요청에 맞는 Action 클래스의 execute() 메서드를 호출 한다.
		메서드를 호출했기에, 기능을 수행하고, 요청을 처리하게 된다.

	3) 요청 처리가 완료 되면, 사용자 에게 응답을 해야 한다.
		View 으로 이동 해야 한다는 말 ~


JAVA는 output을 2개 이상 전달 할 수 없다. >> 무조건 output은 1개.

그럴때마다 VO 객체를 만들어서 return 해줘야 한다.

멤버변수 (프로퍼티 / 속성) 으로 데이터를 전달 할 수 있으니까 ~

암튼, ActionForward 클래스 하나 만들었음..


	4) ActionForward 클래스를 생성 한다.
		경로와 어떤식으로 보낼지에 대한 코드가 작성 되어 있다.


FrontController 패턴 이란 ?

1) Action 인터페이스를 구현한 클래스들은 execute() 메서드로 요청 처리를 모듈화 하고,
2) execute()의 output은 모두, ActionForward 객체인 패턴 이다.

그래서, FrontController 패턴 이라고 한다.

프론트에게 데이터를 전송 하기 위해 필요한 컨트롤러 이기 때문에 이렇게 작성 하는 개념.

그래서 FC 확인해 봤어 ? 하면 이거임.


FrontController 패턴

.do	VS	.jsp
[C]		[V]
상대적으로 가볍다.	상대적으로 무겁다.

-----------------------------

HttpSession session=request.getSession();
         session.setAttribute("mid", mVO.getMid());
